import heapq

# ë§¨í•´íŠ¼ ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
def manhattan(puzzle, goal):
    distance = 0
    for num in range(1, 10):  # 0(ë¹ˆì¹¸)ì€ ê³„ì‚° ì œì™¸
        i = puzzle.index(num)
        gi = goal.index(num)
        x1, y1 = divmod(i, 5)
        x2, y2 = divmod(gi, 5)
        distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

# A* ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
def a_star(start, goal):
    start_tuple = tuple(start)
    goal_tuple = tuple(goal)
    pq = []
    heapq.heappush(pq, (manhattan(start, goal), 0, start_tuple))  # (f=g+h, g, ìƒíƒœ)
    visited = set()
    visited.add(start_tuple)

    while pq:
        f, g, current = heapq.heappop(pq)

        if current == goal_tuple:
            return g  # ìµœì†Œ ì´ë™ íšŸìˆ˜ ë°˜í™˜

        zero_idx = current.index(0)
        x, y = divmod(zero_idx, 5)

        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < 2 and 0 <= ny < 5:
                nidx = nx * 5 + ny
                new = list(current)
                new[zero_idx], new[nidx] = new[nidx], new[zero_idx]
                new_tuple = tuple(new)
                if new_tuple not in visited:
                    visited.add(new_tuple)
                    h = manhattan(new, goal)
                    heapq.heappush(pq, (g + 1 + h, g + 1, new_tuple))
    return -1  # ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°

# ì˜ˆì‹œ ì…ë ¥
start = [1, 2, 3, 4, 5,
         6, 7, 8, 0, 9]

goal = [1, 2, 3, 4, 5,
        6, 7, 8, 9, 0]

# ì‹¤í–‰
moves = a_star(start, goal)
print(f"ğŸ”¢ ìµœì†Œ ì´ë™ íšŸìˆ˜: {moves}")
